---
title: "Introduction to spectrolab"
author: "Jose Eduardo Meireles, Anna K. Schweiger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to spectrolab}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The goal of `spectrolab` is to provide essential functions to process data from portable spectrometers and a common interface other packages can build on. `spectrolab` provides methods to read spectral data, to perform jump correction, vector normalization, and smoothing at the sensor overlap regions. `spectrolab` introduces the S3 class `spectra`, which makes it easy to plot and subset data, and to add and access metadata.  

## Installing and loading `spectrolab`

The best way to get `spectrolab` is to install it directly from GitHub. You will need the `devtools` package to do it.

```{r, eval=FALSE}
library("devtools")
install_github("annakat/spectrolab")
```

Assuming that everything went smoothly, you should be able to load `spectrolab` like any other package.

```{r}
library("spectrolab")
```

The source code can be found on our [_GitHub repository_](https://github.com/annakat/spectrolab). Please report any bugs, send us your questions and comments ... and feel free to contribute!

## Reading spectra: example with `.sig` files

You can read raw spectra using the function `read_spectra()`. You can pass a vector of filenames to `read_spectra()`, but it is usually easier to pass the path of your data folder. 

```{r, eval=FALSE}

# `dir_path` is the directory where our example datasets live
dir_path <- system.file("extdata", "Acer_example", package = "spectrolab")

# Read .sig files
acer_spectra <- read_spectra(path = dir_path, format = "sig")

# Note that `acer_spectra` is a `spectra` object. 
# You can ensure that this is true using the `is_spectra()` function.
is_spectra(acer_spectra)
```

You can inspect your spectra object in several ways. You may want to know how many spectra and how many bands are in there, retrieve the filenames, and you may want to plot the spectra.

```{r, eval=FALSE}
# Simply print the object
acer_spectra

# or look at the vector with the dataset's dimensions
dim(acer_spectra)

# list the file names
names(acer_spectra)

# and plot the spectra
plot(acer_spectra)
```

When plotting `(acer_spectra)` you will notice that the `Acer_example` contains one white reference measurement (the horizontal line around 1.0 reflectance) and one obviously bad measurement (with the dip at the NIR shoulder). During the measurement campaign those two measurement were flagged with "_WR" and "_BAD", respectively. With `read_spectra()` it's easy to exclude flagged files, no matter what flags you have used.

```{r, eval=FALSE}

# Check the filenames to see if there are any flags
names(acer_spectra)

# use `exclude_if_matches` to excluded flagged files
acer_spectra <- read_spectra(path = dir_path, format = "sig",   exclude_if_matches = c("BAD","WR"))

# and check result
plot(acer_spectra)
```
Flagging "unusual" measurements during data collection is a very good idea. However, you can also exclude bad spectra and outliers by subsetting your spectra object. We show you how this works in the section **Subsetting spectra** below. 

### Create spectra from a matrix

If you already have your spectra in a matrix format, you can use the function `as.spectra()` to convert it to a `spectra` object. The matrix **must** be in a specific format. (1) Samples must be in rows and wavelengths in columns. (2) Column names must be the wavelength labels. (3) By default, `as.spectra()` assumes that the sample names are in the first column, but you can supply a different column index by using the `name_idx` argument. Here are two examples, one of a matrix named `spec_matrix_example`, and one of a .csv file with some metadata called `spec_matrix_meta`. 

```{r}
# Read the example data
spec <- spec_matrix_example

# Check out the format of the matrix
spec[1:3, 1:4]

# To convert it to spectra, simply run
spec_from_matrix <- as.spectra(spec, name_idx = 1)

# which is the same as
spec_from_matrix <- as.spectra(spec)

# and again you can plot your data to make sure everything worked okay
plot(spec_from_matrix)
```

```{r, eval=F}
### Our second example is a .csv file with some metadata
dir_path <- system.file("extdata/spec_matrix_meta.csv", package = "spectrolab")
spec_csv <- read.csv(dir_path, check.names = F)

### The sample names are in column 3, the metadata is in columns 1 and 2
achillea_spec <- as.spectra(spec_csv, name_idx = 3, meta_idxs = c(1,2))

### And now you have a spectra object with metadata! 
### You can access the metadata using the `meta()` function. 
achillea_spec
meta(achillea_spec)

### It's also easy to add metadata to a spectra object
my_meta <- c(rnorm(10,2,0.5))

### Let's say this is Nitrogen content
meta(achillea_spec,label = "N_perc") <- my_meta
meta(achillea_spec, "N_perc")

### And to get the same output in vector format
meta(achillea_spec, "N_perc", simplify = T)
```

### Converting a `spectra` object into a matrix

It is also possible to convert a `spectra` object to a matrix format, using the `as.matrix()` function. This is for example useful if you want to export your data in a particular format, such as .csv. `spectrolab` will (1) place wavelengths in columns, assigning wavelength labels to `colnames`, and (2) samples in rows, assigning sample names to `rownames`. Since `R` imposes strict rules on column name formats and sometimes on row names, `as.matrix()` will try to fix potential dimname issues if `fix_names != "none"`.

```{r, eval=F}
# Make a matrix from a `spectra` object
spec_as_mat = as.matrix(spec_from_matrix, fix_names = "none")
spec_as_mat[1:4, 1:3]
```

## Plotting

The workhorse function for plotting `spectra` is `plot()`. It will jointly plot each spectrum in the `spectra` object. You should be able to pass the usual plot arguments to it, such as `col`, `ylab`, `lwd`, etc.

You can also plot the quantile of a `spectra` object with `plot_quantile()`. It's second argument, `total_prob`, is the total "mass" that the quantile encompasses. For instance, a `total_prob = 0.95` covers 95% of the variation in the `spectra` object, i.e. it is the `0.025 to 0.975` quantile. The quantile plot can stand alone or be added to a current plot if `add = TRUE`.

Last but not least, you can also shade spectral regions with the `plot_regions()` function. `spectrolab` provides a `default_spec_regions()` matrix as an example, but you obviously can customize it for your needs.

```{r, fig.height=2.5, fig.width=8, dev_svg}
# Simple spectra plot
par(mfrow = c(1, 3))
plot(spec_from_matrix, lwd = 0.75, lty = 1, col = "grey25", main = "All Spectra")

# Stand along quantile plot
plot_quantile(spec_from_matrix, total_prob = 0.8, col = rgb(1, 0, 0, 0.5), lwd = 0.5, border = TRUE)
title("80% spectral quantile")

# Combined individual spectra, quantiles and shade spectral regions
plot(spec_from_matrix, lwd = 0.25, lty = 1, col = "grey50", main="Spectra, quantile and regions")
plot_quantile(spec_from_matrix, total_prob = 0.8, col = rgb(1, 0, 0, 0.25), border = FALSE, add = TRUE)
plot_regions(spec_from_matrix, regions = default_spec_regions(), add = TRUE)
```

## Querying

`spectrolab` lets you query the `spectra` object and get summary information. You can easily get sample names with `names()` and wavelength labels with `wavelengths()`. If you need the reflectance, you can retrieve it with the `reflectance()` function.

```{r, eval=F}
# Get the vector of all sample names. Note: Duplicated sample names are permitted
n <- names(spec_from_matrix)
n[1:5]

# Get the vector of wavelengths
w <- wavelengths(spec_from_matrix)
w[1:5]

# or the reflectances in matrix format
r <- reflectance(spec_from_matrix)

# First 10 wavelengths of first 5 species
r[1:5,1:10]

# You can also get the dimensions of your `spectra` object
dim(spec_from_matrix)
```

## Subsetting spectra

You can subset the `spectra` using a notation *similar* to the `[i,j]` function used in matrices and data.frames. The first argument in `[i, ]` matches *sample names*, whereas the second argument `[ ,j]` matches the *wavelength names*. Here are some examples of how `[` works in `spectra`:

  - `x[1:3, ]` will keep the first three samples of `x`, i.e. `1:3` are indexes.
  - `x["sp_1", ]` keeps **all** entries in `x` where sample names match `"sp_1"`
  - `x[ ,800:900]` will keep wavelengths between `800` and `900`.
  - `x[ ,1:5] ` will **fail**!. *wavelengths __cannot__ be subset by indexes!*

Subsetting lets you e.g. exclude noisy regions at the beginning and end of the spectrum or limit the data to specific entries.

```{r, fig.height=2.5, fig.width=6, fig.align="center", eval=F}

# Subset wavelength regions 
spec_sub <-  spec_from_matrix[ ,400:700]

# Check the result
plot(spec_sub)

# Subset spectra to all entries where sample_name matches "species_8"
spec_sp8 <- spec_from_matrix["species_8", ]

# Check the results
dim(spec_sp8)

# Plotting the subset result should work just fine
plot(spec_sp8, col = "red", main = "Species 8 spectra")
plot_quantile(spec_sp8, total_prob = 0.75, add = TRUE,  col = rgb(0.2, 0.2, 0.2, 0.2), border = TRUE)
plot_regions(spec_sp8, default_spec_regions(), col = rgb(1, 0.5, 0, 0.1), add = TRUE)
```

Note that you can (1) subset samples using indexes and (2) use characters or numerics to subset wavelengths. As said before, you cannot use indexes to subset wavelengths though.

```{r, eval=F}
# Subsetting samples by indexes works and so does subsetting wavelengths by numerics or characters.
reflectance(spec_sp8[1,"405"]) == reflectance(spec_sp8[1,405])
```

*But remember that you CANNOT use indexes to subset wavelengths!*

```{r, eval=F}
# Something that is obvioulsy an index, like using 2 instead of 401 (the 2nd band 
# in our case), will fail.
spec_sp8[ ,2]

`Error in i_match_ij_spectra(this = this, i = i, j = j) : Wavelength subscript out of bounds. Use wavelength labels instead of raw indices.`
```

However, `spectrolab` cannot detect if you meant to get the two last bands when
you have 2001 in your dataset and use 2000:2001. It will assume that you 
wanted wavelengths "2000" and "2001".
Bottomline, be very careful not to use indexes to subset wavelengths!


## Manipulating samples and wavelength labels

You may want to edit certain simple attributes of `spectra`, such as make all sample names uppercase. This is easily attainable in `spectrolab`:

```{r, eval=F}
spec_new <- spec_from_matrix

# Replace names with an uppercase version
names(spec_new) <- toupper(names(spec_new))

# Check the results
names(spec_new)[1:5]
```

If you want to fiddle with the reflectance itself, this is easy, too.

```{r,  fig.height=3, fig.width=4, fig.align="center", eval=F}
# Scale reflectance by 0.75
spec_new <- spec_new * 0.75

# Plot the results
plot(spec_from_matrix, col = "blue", lwd = 0.75, cex.axis = 0.75)
plot(spec_new, col = "orange", lwd = 0.75, add = TRUE)
```

## Essential processing 

### Jump correction

Some instruments allow you to preserve the sensor overlap regions. This results in duplicated wavelenghts and a "jump" between the VIS/NIR and NIR/SWIR regions. `spectrolab`'s `jump corrector` removes the overlap regions between the VIS/NIR and NIR/SWIR regions, respectively, and corrects the spectra to allow for better transition between the regions, while keeping the spectral information as close to the original as possible. In principle, the algorithm searches for the wavelengths of closest approach in both overlap regions, cuts the spectrum into three pieces, removes the overlap and finds a multiplier to paste the junks back together. No additional smoothing is applied. As a convention, the NIR region is left unchanged, the VIS and SWIR get adjusted.  

```{r, eval=F}
# Read Acer example spectra 
acer_spectra <- read_spectra(path = dir_path, format = "sig",   exclude_if_matches = c("BAD","WR"))

# and check result
plot(acer_spectra)

# Jump correction 
acer_juco <- jump_corr(acer_spectra)

# This looks better!
plot(acer_juco)
```

### Vector normalisation

Treating each spectrum as a vector and standarizing it to unity length is a great way to remove brightness differences (e.g. due to changing lamp power), while preserving the shape of the spectrum (and thus its information content). Vector normalization is implemented in `spectrolab`'s `normalize()` function. Note: If you want to use *Ms. A's* trait coefficients, you need to use vector normalized spectra, limited to the 400 - 2400 nm wavelength range.

```{r, eval=F}
# Subset jump corrected spectra to 400 - 2400 nm 
acer_sub <- acer_juco[, 400:2400]

# and check result
plot(acer_sub)

# Perform vector normalization
acer_vn <- normalize(acer_sub)

# and check result
plot(acer_vn)
```

### Smoothing at overlap regions ... coming soon

Depending on your analysis, it can be a good idea to smooth remaining noise at the sensor overlap regions. 


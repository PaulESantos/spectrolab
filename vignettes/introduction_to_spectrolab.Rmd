---
title: "Introduction to spectrolab"
author: "Jose Eduardo Meireles, Anna K. Schweiger"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to spectrolab}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The goal of `spectrolab` is to provide essential functions to process data from portable spectrometers and a common interface for spectra that other packages can build on. Currently `spectrolab` has been only tested for SVC data (Spectral Vista Inc.). `spectrolab` provides methods to read spectral data files, to perform jump correction, vector normalisation, smoothing at the sensor overlap regions, and to filter out bad measurements. `spectrolab` introduces the S3 class `spectra`, which makes it easy to plot and manipulate data and to access additional metadata.  

## Installing and loading `spectrolab`

The best way to get `spectrolab` is to install it directly from the [_github repository_](www.github.com/annakat/spectrolab). You will need the `devtools` package to do it.

```{r, eval=FALSE}
library("devtools")
install_github("annakat/spectrolab")
```

Assuming that everything went smoothly, you should be able to load `spectrolab` like any other package.

```{r, eval=F}
library("spectrolab")
```

## Reading spectra and creating a `spectra` object

Assume you have a directory with several .sig files, an example can be found in the folder `Acer_example`. During your measurment campaign you might have flagged filenames of obviously bad measurements with "bad" and white reference measurements with "WR", but don't worry if you have not. We can take care of filtering out bad and reference measurements later.

### Read spectra

First you will want to read the raw data files. 

```{r, eval=FALSE}
# Read .sig files
myfolder <- system.file("extdata", "Acer_example", package = "spectrolab")
Acer_spectra <- read.svc(myfolder, read = T, filename = T) 

# Note that this is NOT a spectra object. You can verify this by either asking what class `Acer_spectra` is or using spectrolab's `is_spectra()` function.

class(Acer_spectra)
is_spectra(Acer_spectra)
```

### Constructing a `spectra` object

The `spectra` class holds the essential information used in spectral dataset: reflectance, wavelengths, etc. The class has a bunch of requirements in terms of both format and values. For instance, relative reflectance must be between 0 and 1.

If your data is in a matrix or data.frame with the same format as `Acer_spectra` (check previous section for details), you can construct a `spectra` object by calling the `as.spectra()` function.

```{r, eval=F}
# Make a spectra object if you have a matrix in the right format
spec <- spectrolab::as.spectra(Acer_spectra)

# Did it work?
is_spectra(spec)
```

Alternativelly, you can create a `spectra` object using the more flexible `spectra()` constructor, which takes three arguments: (1) a reflectance matrix, (2) a vector of wavelengths and (3) the sample names.

```{r, eval=F}
# (1) Create a reflectance matrix.
#     In this case, by removing the sample ID column
rf <- Acer_spectra[, -1]

# Check the result
rf[1:4, 1:3]

# (2) Create a vector with wavelength labels that match
#     the reflectance matrix columns.
wl <- colnames(rf)

# Check the result
wl[1:4]

# (3) Create a vector with sample labels that match
#     the reflectance matrix rows.
#     In this case, use the first colum of spec_matrix_example
sn <- Acer_spectra[, 1] 

# Check the result
sn[1:4]

# Finally, construct the spectra object using the `spectra` constructor
spec <- spectra(reflectance = rf, wavelengths = wl, names = sn)

# And hopefully this worked fine
is_spectra(spec)
```

### Plot spectra
Now, you can explore your `spectra` using  `plot()` 

```{r, eval=F}
plot(spec)

### A warning message is displayed because raw SVC data have duplicated wavelenghts at the sensor overlap regions
```

### Converting a `spectra` object into a matrix

It is possible to convert a `spectra` object to a matrix format, using the `as.matrix()` function. `spectrolab` will (1) place wavelengths in columns, assigning wavelength labels to `colnames`, and (2) samples in rows, assigning sample names to `rownames`. Since `R` imposes strict on column name formats and sometimes on row names, `as.matrix()` will try to fix potential dimname issues if `fix_names != "none"`.

```{r, error=TRUE}
# Make a matrix from a `spectra` object
spec_as_mat = as.matrix(spec, fix_names = "none")
spec_as_mat[1:4, 1:3]
```

## Jump correction, clip spectra, remove bad measurements

In most cases, you don't want to work with raw SVC spectra. They contain the sensor overlap regions, in which parts of the spectrum are measured with two sensors (thus the duplicated wavelenghts), noise at the beginning and end of the spectrum and oftentimes "bad" measurements. Here, we illustrate a typical workflow of how to arrive at meaningful `spectra` from a folder containing raw files. 

### Jump correction

The `jump corrector` removes the VIS/NIR and NIR/SWIR overlap regions. In principle, the algorithm searches for the wavelengths of closest approach in both overlap regions, where it cuts the spectrum into three pieces, removes the overlap and finds a multiplier to paste the junks back together. As a convention, the NIR regions is left unchanged.  


```{r, eval=FALSE}
# For convenience, `jump.corr.svc` reads raw data, so there is no need for running `read.svc` fist. Similar to `read.svc` you only need to point `jump.corr.svc` to the folder containing your .sig files. 
myfolder <- system.file("extdata", "Acer_example", package = "spectrolab")
Acer_juco <- jump.corr.svc(myfolder, filename = T)
```

### Clip spectra

Next, you probably want to exclude the noisy regions at the beginning and end of the spectrum. `clip.svc` limits the wavelength range to 400 - 2400 nm. 

```{r, eval=FALSE}
Acer_jucoclip <- clip.svc(Acer_juco)
```

### Smoothing at overlap regions

Depending on your analysis, it can be a good idea to smooth remaining noise at the sensor overlap regions. `smoo.visnir.svc` uses a moving average between 970 - 1025 nm. `smoo.nirswir.svc` uses linear interpolation between 1903 - 1917 nm. Note that we DO NOT use additional smoothing when predicting traits from spectra with PLSR models. 

```{r, eval=FALSE}
### Smooth only VIS/NIR or NIR/SWIR
Acer_smoo1 <- smoo.visnir.svc(Acer_juco)
Acer_smoo2 <- smoo.nirswir.svc(Acer_juco)

### Smooth both regions
Acer_smoo <- smoo.nirswir.svc(Acer_smoo1)
### Same result
Acer_smoo <- smoo.visnir.svc(Acer_smoo2)
```

### Excluding bad spectra

The `spectrolab` package comes with a couple of functions to exclude bad spectra. However, this part of the package will grow, as the problems associated with spectral measurements are different from dataset to dataset. Likewise, functions that do well with removing problematic spectra from one dataset might be too strict when applied to a different dataset. Thus, we suggest an iterative workflow of plotting `spectra` inspecting the `plot` for bad measurements, removing bad measurements, and plotting again, until the output looks fine. 

```{r, eval=FALSE}
### Some common examples, see `excl.` for more.
### Exclude spectra with reflectances at the 'NIR shoulder' @ 761 nm <0.3 or >0.65 
Acer_excl <- excl.hilo.svc(Acer_jucoclip)

### Exclude spectra with high reflectances in VIS: @ 450 nm >0.2 or @400 nm >0.15
Acer_excl <- excl.hi.vis.svc(Acer_jucoclip)
Acer_excl <- excl.hi.start.svc(Acer_jucoclip)

### Exclude spectra with dips in NIR: @800 - @770 >0.02 ###
Acer_excl <- excl.dip.nir.svc(Acer_jucoclip)
```

### Constructing a `spectra` object and plotting

Once your spectra are jump correction, clipped and bad measurements are removed create an object of class `spectra` by calling the `as.spectra()` function, and plot your spectra using `plot()`. 



# Exploring a `spectra` object

`spectrolab` exposes a few ways to plot and query spectral data in `spectra` format. TODO ... 

## Plotting

The workhorse function for plotting `spectra` is `plot()`. It will jointly plot each spectrum in the `spectra` object. You should be able to pass the usual plot arguments to it, such as `col`, `ylab`, etc.

You can also plot the quantile of a `spectra` object with `plot_quantile()`. It's second argument, `total_prob`, is the total "mass" that the quantile encompasses. For instance, a `total_prob = 0.95` covers 95% of the variation in the `spectra` object; i.e. it is the `0.025 to 0.975` quantile. The quantile plot can stand alone or be added to a current plot if `add = TRUE`.

Last but not least, you can also shade spectral regions with the `plot_spec_regions()` function. `spectrolab` provides a `default_spec_regions()` matrix as an example, but you obviously can customize it for your needs.

```{r, fig.height=2.5, fig.width=8, eval=F}
par(mfrow = c(1, 3))

# Simple spectra plot
plot(spec, lwd = 0.75, lty = 1, col = "grey25", main = "All Spectra")

# Stand along quantile plot
plot_quantile(spec, total_prob = 0.8, main = "80% spectral quantile", 
              col = rgb(1, 0, 0, 0.5), lwd = 0.5, border = TRUE)

# Combined quantile and individual spctra plot
# With an added bonus of shading 4 spectral regions
plot(spec, lwd = 0.25, lty = 1, col = "grey50", "Spectra, quantile and regions")
plot_quantile(spec, total_prob = 0.8, 
              col = rgb(1, 0, 0, 0.25), add = TRUE, border = FALSE)
plot_spec_regions(spec, regions = default_spec_regions(), add = TRUE)
```

## Querying

`spectrolab` lets you query the `spectra` object and get summary infomation. You can easly get sample names with `names()` and wavelength labels with `wavelengths()`. It is also possible to recover the 

```{r, eval=F}
# Get the vector of all sample names
# Note that duplicate sample names are permitted
n = names(spec)
n[1:5]

# Or get the vector of wavelengths
w = wavelengths(spec)
w[1:5]

# You can also get the dimensions of your `spectra` object
dim(spec)
```

If you really need the raw reclectance, you can retrieve it with the `reflectance()` function.

## Subsetting spectra

You can subset the `spectra` using a notation *similar* to the `[ i , j]` function used in matrices and data.frames. The first argument in `[ i, ]` matches *sample names*, whereas the second argument `[ , j ]` matches the *wavelength names*. Here are some examples of how `[` works in `specrta`:

  - `x[ 1:3 , ]` will keep the first three samples of `x`. I.e. `1:3` are indexes.
  - `x[ "sp_1" , ]` keeps **all** entries in `x` where sample names match `"sp_1"`
  - `x[  , 800:900 ]` will keep wavelengths between `800` and `900`.
  - `x[  , 1:5 ] ` will **fail**!. *wavelengths __cannot__ be subset by index!*

```{r, fig.height=2.5, fig.width=6, fig.align="center", eval=F}
# Subset spectra to all entries where sample_name matches "species_8"
spec_sp8 = spec[ "species_8", ]

# Check the results
dim(spec_sp8)

# Plotting the seubset result should work just fine
par(mfrow = c(1, 2), cex.main = 0.8, cex.axis = 0.6, cex.lab = 0.8)

plot(spec_sp8, col = "red", main = "Species 8 spectra")
plot_quantile(spec, total_prob = 1.0, add = TRUE,  col = rgb(0.2, 0.2, 0.2, 0.2), border = FALSE)
plot_spec_regions(spec_sp8, default_spec_regions(), col = rgb(1, 0.5, 0, 0.1), add = TRUE)

# And maybe further subset to the visible wavelengths only
spec_sp8 = spec_sp8[ , 400:700 ]

# This subset should still plot just fine
plot(spec_sp8, col = "red", main = "Visible spectra for species 8")
plot_quantile(spec, total_prob = 1.0, add = TRUE,  col = rgb(0.2, 0.2, 0.2, 0.2), border = FALSE)
```

Note that you can (1) subset samples using indexes and (2) use character or numeric to subset wavelengths. As said before, you cannot use indexes to subset wavelengths though.

```{r, error=TRUE}
# Subset samples by index should work. It is also OK to subset by wavelength 
# using numerics or characters.
reflectance(spec_sp8[ 1 , "405"]) == reflectance(spec_sp8[ 1 , 405])

#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#
# But remember that you CANNOT use indexes to subset wavelengths!
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!#

# Something that is obvioulsy an index, like using 2 instead of 401 (the 2nd band), will fail.
spec_sp8[ , 2 ]

# However, `spectrolab` canot detect if you meant to get the two last bands when
# you use 2000:2001. It will assume that you wanted wavelengths "2000" and "2001"
# Bottomline, be very careful not to use indexes to subset wavelengths!
```

## Manipulating samples and wavelength labels

You may want to edit certain simple attributes of `spectra`, such as make all sample names uppercase. This is easlily attainable in `spectrolab`:

```{r, eval=F}
spec_new = spec

# Replace names with an uppercase version
names(spec_new) = toupper(names(spec_new))

# Check the results
names(spec_new)[1:5]
```

You may want to fiddle with the reflectance itself. This is easy to do, but there are some constraints. For example, `spectrolab` will not allow you to have negative reflectance values or values greater than 1.

```{r,  fig.height=3, fig.width=4, fig.align="center", eval=F}
# Scale reflectance by 0.75
# spec_new[] = reflectance(spec_new) * 0.75
spec_new = spec_new * 0.75

# Plot the results
plot(spec, col = "blue", lwd = 0.75, cex.axis = 0.75)
plot(spec_new, col = "orange", lwd = 0.75, add = TRUE)
```

However, `spectrolab` will throw an error if you try to perform an illegal operation to reflectance, for instance 

```{r, error=TRUE}
# Trying to add 1.0 to all reflectance values will fail.
spec_new[] = reflectance(spec_new) + 1.0
```


